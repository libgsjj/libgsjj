<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libgsjj: gsjj::passive Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libgsjj
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">Deterministic finite automata learning library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegsjj.html">gsjj</a></li><li class="navelem"><a class="el" href="namespacegsjj_1_1passive.html">passive</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gsjj::passive Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines the passive methods for automatically learning deterministic finite automata.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegsjj_1_1passive_1_1CNF"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive_1_1CNF.html">CNF</a></td></tr>
<tr class="memdesc:namespacegsjj_1_1passive_1_1CNF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains every method that relies on a SAT solver with <a class="el" href="namespacegsjj_1_1passive_1_1CNF.html" title="Contains every method that relies on a SAT solver with CNF clauses. ">CNF</a> clauses. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegsjj_1_1passive_1_1NonCNF"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive_1_1NonCNF.html">NonCNF</a></td></tr>
<tr class="memdesc:namespacegsjj_1_1passive_1_1NonCNF"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains every method that relies on a SAT solver that works on any boolean formula. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegsjj_1_1passive_1_1SMT"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive_1_1SMT.html">SMT</a></td></tr>
<tr class="memdesc:namespacegsjj_1_1passive_1_1SMT"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains every method that relies on a <a class="el" href="namespacegsjj_1_1passive_1_1SMT.html" title="Contains every method that relies on a SMT solver. ">SMT</a> solver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of all passive methods.  <a href="classgsjj_1_1passive_1_1Method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsjj_1_1passive_1_1MethodFactory.html">MethodFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Factory Builder design pattern adapted to our methods.  <a href="classgsjj_1_1passive_1_1MethodFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsjj_1_1passive_1_1RegisterInFactory.html">RegisterInFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to register a method in the factory.  <a href="classgsjj_1_1passive_1_1RegisterInFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab144a441d83d1d16f7e63d782866501b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#ab144a441d83d1d16f7e63d782866501b">constructMethod</a> (const std::string &amp;name, unsigned int n, const std::set&lt; std::string &gt; &amp;Sp, const std::set&lt; std::string &gt; &amp;Sm)</td></tr>
<tr class="memdesc:ab144a441d83d1d16f7e63d782866501b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the alphabet and the prefixes set from Sp and Sm and constructs a method for a fixed number of states.  <a href="#ab144a441d83d1d16f7e63d782866501b">More...</a><br /></td></tr>
<tr class="separator:ab144a441d83d1d16f7e63d782866501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1cc0609f1b306e259d02b1773d8658"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#a0a1cc0609f1b306e259d02b1773d8658">constructMethod</a> (const std::string &amp;name, unsigned int n, const std::set&lt; std::string &gt; &amp;Sp, const std::set&lt; std::string &gt; &amp;Sm, const std::set&lt; std::string &gt; &amp;S, const std::set&lt; std::string &gt; &amp;prefixes, const std::set&lt; char &gt; &amp;alphabet)</td></tr>
<tr class="memdesc:a0a1cc0609f1b306e259d02b1773d8658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a method for a fixed number of states.  <a href="#a0a1cc0609f1b306e259d02b1773d8658">More...</a><br /></td></tr>
<tr class="separator:a0a1cc0609f1b306e259d02b1773d8658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7eb4446a9c4f5b5fecb61c319911587"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#ac7eb4446a9c4f5b5fecb61c319911587">constructMethod</a> (const std::string &amp;name, const std::set&lt; std::string &gt; &amp;Sp, const std::set&lt; std::string &gt; &amp;Sm, const std::chrono::seconds &amp;timeLimit=std::chrono::seconds(0), long double *timeTaken=nullptr)</td></tr>
<tr class="memdesc:ac7eb4446a9c4f5b5fecb61c319911587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the alphabet and the prefixes set from Sp and Sm and constructs a method with the smallest possible number of states.  <a href="#ac7eb4446a9c4f5b5fecb61c319911587">More...</a><br /></td></tr>
<tr class="separator:ac7eb4446a9c4f5b5fecb61c319911587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5333c896cf78d51187b3977eefbca5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#ace5333c896cf78d51187b3977eefbca5">constructMethod</a> (const std::string &amp;name, const std::set&lt; std::string &gt; &amp;Sp, const std::set&lt; std::string &gt; &amp;Sm, const std::set&lt; std::string &gt; &amp;S, const std::set&lt; std::string &gt; &amp;prefixes, const std::set&lt; char &gt; &amp;alphabet, const std::chrono::seconds &amp;timeLimit=std::chrono::seconds(0), long double *timeTaken=nullptr)</td></tr>
<tr class="memdesc:ace5333c896cf78d51187b3977eefbca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a method with the smallest possible number of states.  <a href="#ace5333c896cf78d51187b3977eefbca5">More...</a><br /></td></tr>
<tr class="separator:ace5333c896cf78d51187b3977eefbca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f2e12ab7d67cf134acd98009868dc6"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#ab6f2e12ab7d67cf134acd98009868dc6">computeS</a> (const std::set&lt; std::string &gt; &amp;Sp, const std::set&lt; std::string &gt; &amp;Sm)</td></tr>
<tr class="memdesc:ab6f2e12ab7d67cf134acd98009868dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$S = S_+ \cup S_-$" src="form_16.png"/>.  <a href="#ab6f2e12ab7d67cf134acd98009868dc6">More...</a><br /></td></tr>
<tr class="separator:ab6f2e12ab7d67cf134acd98009868dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8434ca88a6d8161698fb5b823dd5c7"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#a8c8434ca88a6d8161698fb5b823dd5c7">computePrefixes</a> (const std::set&lt; std::string &gt; &amp;S)</td></tr>
<tr class="memdesc:a8c8434ca88a6d8161698fb5b823dd5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <img class="formulaInl" alt="$Pref(S)$" src="form_19.png"/>.  <a href="#a8c8434ca88a6d8161698fb5b823dd5c7">More...</a><br /></td></tr>
<tr class="separator:a8c8434ca88a6d8161698fb5b823dd5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf0e78e92bacb37939193e63545ce7e"><td class="memItemLeft" align="right" valign="top">std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#a2cf0e78e92bacb37939193e63545ce7e">computeAlphabet</a> (const std::set&lt; std::string &gt; &amp;S)</td></tr>
<tr class="memdesc:a2cf0e78e92bacb37939193e63545ce7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the alphabet <img class="formulaInl" alt="$\Sigma$" src="form_10.png"/> from the words in <img class="formulaInl" alt="$S$" src="form_4.png"/>.  <a href="#a2cf0e78e92bacb37939193e63545ce7e">More...</a><br /></td></tr>
<tr class="separator:a2cf0e78e92bacb37939193e63545ce7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b46545d1084387519598dca068d02c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#a43b46545d1084387519598dca068d02c">readFromFile</a> (const std::string &amp;inputFile, std::set&lt; std::string &gt; &amp;Sp, std::set&lt; std::string &gt; &amp;Sm)</td></tr>
<tr class="memdesc:a43b46545d1084387519598dca068d02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <img class="formulaInl" alt="$S_+$" src="form_2.png"/> and <img class="formulaInl" alt="$S_-$" src="form_3.png"/> sets from a file.  <a href="#a43b46545d1084387519598dca068d02c">More...</a><br /></td></tr>
<tr class="separator:a43b46545d1084387519598dca068d02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7cf11070576ef0c21980412f142fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#a0e7cf11070576ef0c21980412f142fc7">generateRandomly</a> (unsigned int numberWords, unsigned int minLength, unsigned int maxLength, unsigned int alphabetSize, std::set&lt; std::string &gt; &amp;Sp, std::set&lt; std::string &gt; &amp;Sm, double SpProbability=0.5)</td></tr>
<tr class="memdesc:a0e7cf11070576ef0c21980412f142fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates randomly a sample set.  <a href="#a0e7cf11070576ef0c21980412f142fc7">More...</a><br /></td></tr>
<tr class="separator:a0e7cf11070576ef0c21980412f142fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5005bf7d43d31139d789247b28f70fae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#a5005bf7d43d31139d789247b28f70fae">constructMethodTrigger</a> (const std::string &amp;name, unsigned int n, const std::set&lt; std::string &gt; &amp;Sp, const std::set&lt; std::string &gt; &amp;Sm, const std::set&lt; std::string &gt; &amp;S, const std::set&lt; std::string &gt; &amp;prefixes, const std::set&lt; char &gt; &amp;alphabet, const std::chrono::seconds &amp;timeLimit, std::atomic_bool &amp;stopTrigger, const bool *stopPointer)</td></tr>
<tr class="separator:a5005bf7d43d31139d789247b28f70fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad697e5c21ffd5fb6f28409caf145efbc"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::string, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsjj_1_1passive.html#ad697e5c21ffd5fb6f28409caf145efbc">allMethods</a></td></tr>
<tr class="memdesc:ad697e5c21ffd5fb6f28409caf145efbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array with every possible method choice.  <a href="#ad697e5c21ffd5fb6f28409caf145efbc">More...</a><br /></td></tr>
<tr class="separator:ad697e5c21ffd5fb6f28409caf145efbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the passive methods for automatically learning deterministic finite automata. </p>
<p>These methods receive a sample <img class="formulaInl" alt="$S = (S_+, S_-)$" src="form_0.png"/> where</p><ul>
<li><img class="formulaInl" alt="$S_+$" src="form_2.png"/> is the set of words the automaton must accept</li>
<li><img class="formulaInl" alt="$S_-$" src="form_3.png"/> is the set of words the automaton must reject</li>
</ul>
<p>The words that are not in <img class="formulaInl" alt="$S_+$" src="form_2.png"/> nor in <img class="formulaInl" alt="$S_-$" src="form_3.png"/> can be either accepted or rejected (depending on the generated <a class="el" href="classgsjj_1_1DFA.html" title="A Deterministic Finite Automaton. ">DFA</a>) </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2cf0e78e92bacb37939193e63545ce7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf0e78e92bacb37939193e63545ce7e">&#9670;&nbsp;</a></span>computeAlphabet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; char &gt; gsjj::passive::computeAlphabet </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the alphabet <img class="formulaInl" alt="$\Sigma$" src="form_10.png"/> from the words in <img class="formulaInl" alt="$S$" src="form_4.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The set <img class="formulaInl" alt="$S$" src="form_4.png"/> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00025">25</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="a8c8434ca88a6d8161698fb5b823dd5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8434ca88a6d8161698fb5b823dd5c7">&#9670;&nbsp;</a></span>computePrefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; gsjj::passive::computePrefixes </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$Pref(S)$" src="form_19.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The set <img class="formulaInl" alt="$S$" src="form_4.png"/> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00015">15</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="ab6f2e12ab7d67cf134acd98009868dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f2e12ab7d67cf134acd98009868dc6">&#9670;&nbsp;</a></span>computeS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; gsjj::passive::computeS </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes <img class="formulaInl" alt="$S = S_+ \cup S_-$" src="form_16.png"/>. </p>
<p>In theory, we have <img class="formulaInl" alt="$S = (S_+, S_-)$" src="form_0.png"/>. However, we need to compute <img class="formulaInl" alt="$Pref(S_+, S_-)$" src="form_20.png"/>. Therefore, it's easier to have <img class="formulaInl" alt="$S = S_+ \cup S_-$" src="form_16.png"/> and compute <img class="formulaInl" alt="$Pref(S)$" src="form_19.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sp</td><td>The <img class="formulaInl" alt="$S_+$" src="form_2.png"/> set </td></tr>
    <tr><td class="paramname">Sm</td><td>The <img class="formulaInl" alt="$S_-$" src="form_3.png"/> set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set <img class="formulaInl" alt="$S = S_+ \cup S_-$" src="form_16.png"/> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00009">9</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="ab144a441d83d1d16f7e63d782866501b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab144a441d83d1d16f7e63d782866501b">&#9670;&nbsp;</a></span>constructMethod() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt; gsjj::passive::constructMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the alphabet and the prefixes set from Sp and Sm and constructs a method for a fixed number of states. </p>
<p>Sp and Sm must be disjoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the method to construct </td></tr>
    <tr><td class="paramname">n</td><td>The number of states </td></tr>
    <tr><td class="paramname">Sp</td><td>The <img class="formulaInl" alt="$S_+$" src="form_2.png"/> set </td></tr>
    <tr><td class="paramname">Sm</td><td>The <img class="formulaInl" alt="$S_-$" src="form_3.png"/> set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A method to construct the <a class="el" href="classgsjj_1_1DFA.html" title="A Deterministic Finite Automaton. ">DFA</a> for the sample <img class="formulaInl" alt="$(S_+, S_-)$" src="form_18.png"/> </dd></dl>

<p class="definition">Definition at line <a class="el" href="MethodFactory_8cpp_source.html#l00050">50</a> of file <a class="el" href="MethodFactory_8cpp_source.html">MethodFactory.cpp</a>.</p>

</div>
</div>
<a id="a0a1cc0609f1b306e259d02b1773d8658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1cc0609f1b306e259d02b1773d8658">&#9670;&nbsp;</a></span>constructMethod() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt; gsjj::passive::constructMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a method for a fixed number of states. </p>
<p>Sp and Sm must be disjoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the method to construct </td></tr>
    <tr><td class="paramname">n</td><td>The number of states </td></tr>
    <tr><td class="paramname">Sp</td><td>The <img class="formulaInl" alt="$S_+$" src="form_2.png"/> set </td></tr>
    <tr><td class="paramname">Sm</td><td>The <img class="formulaInl" alt="$S_-$" src="form_3.png"/> set </td></tr>
    <tr><td class="paramname">S</td><td>The <img class="formulaInl" alt="$S = S_+ \cup S_-$" src="form_16.png"/> set. See <a class="el" href="namespacegsjj_1_1passive.html#ab6f2e12ab7d67cf134acd98009868dc6" title="Computes . ">passive::computeS</a> </td></tr>
    <tr><td class="paramname">prefixes</td><td>The <img class="formulaInl" alt="$Pref(S)$" src="form_19.png"/> set. See <a class="el" href="namespacegsjj_1_1passive.html#a8c8434ca88a6d8161698fb5b823dd5c7" title="Computes . ">passive::computePrefixes</a> </td></tr>
    <tr><td class="paramname">alphabet</td><td>The alphabet. See computeAlphabet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A method to construct the <a class="el" href="classgsjj_1_1DFA.html" title="A Deterministic Finite Automaton. ">DFA</a> for the sample <img class="formulaInl" alt="$(S_+, S_-)$" src="form_18.png"/> </dd></dl>

<p class="definition">Definition at line <a class="el" href="MethodFactory_8cpp_source.html#l00058">58</a> of file <a class="el" href="MethodFactory_8cpp_source.html">MethodFactory.cpp</a>.</p>

</div>
</div>
<a id="ac7eb4446a9c4f5b5fecb61c319911587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7eb4446a9c4f5b5fecb61c319911587">&#9670;&nbsp;</a></span>constructMethod() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt;, bool &gt; gsjj::passive::constructMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::seconds &amp;&#160;</td>
          <td class="paramname"><em>timeLimit</em> = <code>std::chrono::seconds(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double *&#160;</td>
          <td class="paramname"><em>timeTaken</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the alphabet and the prefixes set from Sp and Sm and constructs a method with the smallest possible number of states. </p>
<p>This uses a binary search to find the minimal number of states</p>
<p>Sp and Sm must be disjoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the method to construct </td></tr>
    <tr><td class="paramname">Sp</td><td>The <img class="formulaInl" alt="$S_+$" src="form_2.png"/> set </td></tr>
    <tr><td class="paramname">Sm</td><td>The <img class="formulaInl" alt="$S_-$" src="form_3.png"/> set </td></tr>
    <tr><td class="paramname">timeLimit</td><td>The time in seconds the program can take to find the best possible method. If the time limit is reached, the function returns the best method found so far. </td></tr>
    <tr><td class="paramname">timeTaken</td><td>If not nullptr, the total time used to solve the different formulas is written. It does NOT give the full CPU time to find the best number of states, juste the time used by the SAT/SMT solvers! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A method to construct the <a class="el" href="classgsjj_1_1DFA.html" title="A Deterministic Finite Automaton. ">DFA</a> for the sample <img class="formulaInl" alt="$(S_+, S_-)$" src="form_18.png"/> and a boolean. The boolean is true iff the function did not reach the time limit. </dd></dl>

<p class="definition">Definition at line <a class="el" href="MethodFactory_8cpp_source.html#l00062">62</a> of file <a class="el" href="MethodFactory_8cpp_source.html">MethodFactory.cpp</a>.</p>

</div>
</div>
<a id="ace5333c896cf78d51187b3977eefbca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5333c896cf78d51187b3977eefbca5">&#9670;&nbsp;</a></span>constructMethod() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a> &gt;, bool &gt; gsjj::passive::constructMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::seconds &amp;&#160;</td>
          <td class="paramname"><em>timeLimit</em> = <code>std::chrono::seconds(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double *&#160;</td>
          <td class="paramname"><em>timeTaken</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a method with the smallest possible number of states. </p>
<p>This uses a binary search to find the minimal number of states</p>
<p>Sp and Sm must be disjoint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the method to construct </td></tr>
    <tr><td class="paramname">Sp</td><td>The <img class="formulaInl" alt="$S_+$" src="form_2.png"/> set </td></tr>
    <tr><td class="paramname">Sm</td><td>The <img class="formulaInl" alt="$S_-$" src="form_3.png"/> set </td></tr>
    <tr><td class="paramname">S</td><td><img class="formulaInl" alt="$S = S_+ \cup S_-$" src="form_16.png"/>. See <a class="el" href="namespacegsjj_1_1passive.html#ab6f2e12ab7d67cf134acd98009868dc6" title="Computes . ">passive::computeS</a> </td></tr>
    <tr><td class="paramname">prefixes</td><td>The set of prefixes of <img class="formulaInl" alt="$S$" src="form_4.png"/>. See <a class="el" href="namespacegsjj_1_1passive.html#a8c8434ca88a6d8161698fb5b823dd5c7" title="Computes . ">passive::computePrefixes</a> </td></tr>
    <tr><td class="paramname">alphabet</td><td>The alphabet of <img class="formulaInl" alt="$S$" src="form_4.png"/>. See <a class="el" href="namespacegsjj_1_1passive.html#a2cf0e78e92bacb37939193e63545ce7e" title="Computes the alphabet  from the words in . ">passive::computeAlphabet</a> </td></tr>
    <tr><td class="paramname">timeLimit</td><td>The time in milliseconds the program can take to find the best possible method. If the time limit is reached, the function returns the best method found so far. </td></tr>
    <tr><td class="paramname">timeTaken</td><td>If not nullptr, the total time used to solve the different formulas is written. It does NOT give the full CPU time to find the best number of states, juste the time used by the SAT/SMT solvers! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A method to construct the <a class="el" href="classgsjj_1_1DFA.html" title="A Deterministic Finite Automaton. ">DFA</a> for the sample <img class="formulaInl" alt="$(S_+, S_-)$" src="form_18.png"/> and a boolean. The boolean is true iff the function did not reach the time limit. </dd></dl>

<p class="definition">Definition at line <a class="el" href="MethodFactory_8cpp_source.html#l00070">70</a> of file <a class="el" href="MethodFactory_8cpp_source.html">MethodFactory.cpp</a>.</p>

</div>
</div>
<a id="a5005bf7d43d31139d789247b28f70fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5005bf7d43d31139d789247b28f70fae">&#9670;&nbsp;</a></span>constructMethodTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classgsjj_1_1passive_1_1Method.html">Method</a>&gt; gsjj::passive::constructMethodTrigger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>alphabet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::seconds &amp;&#160;</td>
          <td class="paramname"><em>timeLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic_bool &amp;&#160;</td>
          <td class="paramname"><em>stopTrigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>stopPointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MethodFactory_8cpp_source.html#l00041">41</a> of file <a class="el" href="MethodFactory_8cpp_source.html">MethodFactory.cpp</a>.</p>

</div>
</div>
<a id="a0e7cf11070576ef0c21980412f142fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7cf11070576ef0c21980412f142fc7">&#9670;&nbsp;</a></span>generateRandomly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gsjj::passive::generateRandomly </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alphabetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>SpProbability</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates randomly a sample set. </p>
<p>The alphabet's size is at most 10.</p>
<p>The functions ensures that Sp and Sm do not contain a common word. It must be possible to generate enough words. Otherwise, this function will never terminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberWords</td><td>The total number of words to generate </td></tr>
    <tr><td class="paramname">minLength</td><td>The minimum size of each word </td></tr>
    <tr><td class="paramname">maxLength</td><td>The maximum size of each word </td></tr>
    <tr><td class="paramname">alphabetSize</td><td>The size of the alphabet. Since symbols are taken randomly in the alphabet, it may happen that a sampling set uses a smaller alphabet. </td></tr>
    <tr><td class="paramname">Sp</td><td>The words to accept are put in this set </td></tr>
    <tr><td class="paramname">Sm</td><td>The words to reject are put in this set </td></tr>
    <tr><td class="paramname">SpProbability</td><td>The probability that a word is put in Sp (by default, 0.5) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00052">52</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<a id="a43b46545d1084387519598dca068d02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b46545d1084387519598dca068d02c">&#9670;&nbsp;</a></span>readFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gsjj::passive::readFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>inputFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the <img class="formulaInl" alt="$S_+$" src="form_2.png"/> and <img class="formulaInl" alt="$S_-$" src="form_3.png"/> sets from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputFile</td><td>The path to the file to read </td></tr>
    <tr><td class="paramname">Sp</td><td>The set <img class="formulaInl" alt="$S_+$" src="form_2.png"/> to fill </td></tr>
    <tr><td class="paramname">Sm</td><td>The set <img class="formulaInl" alt="$S_-$" src="form_3.png"/> to fill </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utils_8cpp_source.html#l00035">35</a> of file <a class="el" href="utils_8cpp_source.html">utils.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad697e5c21ffd5fb6f28409caf145efbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad697e5c21ffd5fb6f28409caf145efbc">&#9670;&nbsp;</a></span>allMethods</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;std::string, 8&gt; gsjj::passive::allMethods</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">            <span class="stringliteral">&quot;biermann&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;unary&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;binary&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;heule&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;neider&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;unaryNonCNF&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;binaryNonCNF&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;heuleNonCNF&quot;</span></div><div class="line">        }</div></div><!-- fragment -->
<p>An array with every possible method choice. </p>
<p>Useful to iterate over the methods </p>

<p class="definition">Definition at line <a class="el" href="Method_8h_source.html#l00025">25</a> of file <a class="el" href="Method_8h_source.html">Method.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
